## CS Study - Section115 가상기억장치 구현 기법 / 페이지 교체 알고리즘
### ✏️ Study
#### 💡 가상기억장치의 개요
가상기억장치는 보조 기억 장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법이다.
- 프로그램을 여러 개의 작은 블록 단위로 나누어서 가상 기억 장치에 보관해놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리한다.
- 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용한다.
- 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다.
- 가상기억장치에 저장된 프로그램을 실행하려면 가상 기억 장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환이 필요하다.
- 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있다.
- 가상기억정치의 일반적인 구현 방법에는 블록의 종류에 따라 페이징 기법과 세그먼테이션 기법으로 나눌 수 있다.
<br><br>

#### 💡 페이징 기법
페이징 기법은 가상 기억 장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법이다.
- 페이지와 페이지 프레임
- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다.
- 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블이 필요하다.
- 페이지 맵 테이블 사용으로 비용이 증가되고, 처리 속도가 감소된다.
<br><br>

#### 💡 세그먼테이션 기법
세그먼테이션 기법은 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법이다.
- 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다.
- 기억장치의 사용자 관점을 보존하는 기억장치 관리 기법이다.
- 세그먼테이션 기법을 이용하는 궁극적인 이유는 기억공간을 절약하기 위해서이다.
- 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블이 필요하다.
- 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 기억장치 보호키가 필요하다.
- 내부단편화는 발생하지 않으나 외부 단편화는 발생할 수 있다.
<br><br>

#### 💡 페이지 교체 알고리즘
페이지 교체 알고리즘은 페이지 부재가 발생했을 떄 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법이다.
- OPT(OPTimal replacement, 최적 교체)
  - 앞으로 가장 오랫동안 사용하지 않을 페이지가 교체 대상
  - 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘이다.
- FIFO(First In First Out)
  - 각 페이지가 주기억장치에 적재될 때마다 그 때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지가 교체 대상
- LRU(Least Recently Used)
  - 최근에 가장 오랫동안 사용하지 않은 페이지가 교체 대상
  - 각 페이지마다 계수기나 스택을 두어 현 시점에서 가장 오랫동안 사용하지 않은, 각 가장 오래전에 사용된 페이지를 교체한다.
- LFU(Least Frequently Used)
  - 사용빈도가 가장 적은 페이지가 교체 대상
- NUR(Not Used Recently)
  - LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지가 교체 대상
  - LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있다.
  - 최근의 사용 여부를 확인하기 위해 각 페이지마다 두 개의 비트(참조 비트와 변형 비트)가 사용된다.
- SCR(Second Chance Replacement, 2차 교체 기회)
  - 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완한다.