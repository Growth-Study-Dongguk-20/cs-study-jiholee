## CS Study - Section023 디자인 패턴
### ✏️ Study
#### 💡 디자인 패턴의 개요
각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.
- '바퀴를 다시 발명하지 마라.' 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적이다.
- 대표 디자인 패턴은 1995년 GoF의 디자인 패턴이다.
- GoF 디자인 패턴은 유형에 따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성된다.
- "아키텍처 패턴" VS "디자인 패턴" : 아키텍처 패턴은 디자인 패턴보다 상위 수준의 설계에 사용된다.
<br><br>

#### 💡 디자인 패턴 사용의 장단점
- 장점
1. 범용적인 코딩 스타일로 인해 구조 파악이 용이하다.
2. 객체지향 설계 및 구현의 생산성을 높이는 데 적합하다.
3. 검증된 구조의 재사용을 통해 개발 시간과 비용이 절약된다.
4. 개발자 간 원활한 의사소통이 가능하다.
5. 설계 변경 요청에 대한 유연한 대처가 가능하다.

- 단점
1. 초기 투자 비용이 부담될 수 있다.
2. 객체지향 기반이 아닌 애플리케이션 개발에는 적합하지 않다.
<br><br>

#### 💡 생성 패턴(Creational Pattern)
객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더해 준다.
1. 추상 팩토리 : 구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 연관/의존하는 객체들의 그룹으로 생성하여 추상적으로 표현한다. 
   연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능하다.
2. 빌더 : 작게 분리된 인스턴스를 조합하여 객체를 생성한다. 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있다.
3. 팩토리 메소드 : 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다. 상위 클래스에서는 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다.
4. 프로토타입 : 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴이다.
5. 싱글톤 : 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 동시에 참조할 수는 없다. 불필요한 메모리 낭비를 최소화한다.
<br><br>

#### 💡 구조 패턴(Structural Pattern)
클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴으로, 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.
1. 어댑터 : 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴이다.
2. 브리지 : 구현부에서 추상층을 분리하여 서로가 독립적으로 확장할 수 있도록 구성한 패턴으로, 기능과 구현을 두 개의 별도 클래스로 구현한다.
3. 컴포지트 : 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴이다.
4. 데코레이터 : 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴이다.
5. 퍼싸드 : 복잡한 서브 클래스들을 피해 더 상위에 인터페이스들을 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴이다.(Wrapper 객체 필요)
6. 플라이웨이트 : 가능한 한 인스턴스를 공유해서 사용하여 메모리를 절약하는 패턴이다.
7. 프록시 : 접근이 어려운 객체에 연결하기 위해 인터페이스 역할을 수행하는 패턴이다. 네트워크 연결, 메모리 대용량 객체로의 접근 등에 주로 이용한다.
<br><br>

#### 💡 행위 패턴(Behavioral Pattern)
클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로, 결합도를 최소화할 수 있도록 도와준다.
1. 책임 연쇄 : 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴이다.
2. 커맨드 : 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴이다.
3. 인터프리터 : 언어에 문법 표현을 정의하는 패턴이다.
4. 반복자 : 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴이다.
5. 중재자 : 복잡한 인터페이스들을 캡슐화하여 객체로 정의하는 패턴이다.
6. 메멘토 : 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 되돌릴 수 있는 기능을 제공하는 패턴이다.
7. 옵서버 : Publish-> Subscribe
8. 상태
9. 전략
10. 템플릿 메소드
11. 방문자